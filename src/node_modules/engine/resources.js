/* eslint no-console: 'off' */
import Animation from './Animation';
import {Atlas} from 'texture-atlas';
import axios from 'axios';
import {BaseTexture, Rectangle, Texture, utils} from 'pixi.js';
import * as howler from 'howler';
import naturalSort from 'javascript-natural-sort';
import {audioMap, textureMap} from 'shared/config';

export const rawCache = Object.create(null);
export const audioCache = Object.create(null);
export const baseTextureCache = utils.BaseTextureCache;
export const textureCache = utils.TextureCache;

export function loadAnimation(key, fps) {
  const textures = Object.keys(textureCache)
    .filter((s) => s.startsWith(key))
    .sort(naturalSort)
    .map((s) => Texture.fromFrame(s));
  return new Animation(textures, fps);
}

export function destroy() {
  for (const key in textureCache) {
    textureCache[key].destroy();
    delete textureCache[key];
  }
  for (const key in baseTextureCache) {
    baseTextureCache[key].destroy();
    delete baseTextureCache[key];
  }
  for (const key in audioCache) {
    delete audioCache[key];
  }
  for (const key in rawCache) {
    delete rawCache[key];
  }
}

export function init({pack = true} = {}) {
  return Promise.all([loadAudio(), loadTextures(pack)]);
}

function loadAudio() {
  return new Promise((resolve, reject) => {
    axios.get(audioMap)
      .then((response) => {
        let soundsRemaining = 0;
        const onSoundLoad = () => {
          soundsRemaining -= 1;
          if (!soundsRemaining) {
            resolve();
          }
        };
        const map = response.data;
        for (const key in map) {
          const url = map[key];
          soundsRemaining += 1;
          const sound = new howler.Howl({
            src: [url],
            onload: () => {
              console.info(`Loaded audio "${key}" from URL "${url}"`);
              audioCache[key] = sound;
              onSoundLoad();
            },
            onloaderror: () => {
              console.error(`Failed to load audio "${key}" from URL "${url}"`);
              onSoundLoad();
            },
          });
        }
      })
      .catch((err) => reject(err));
  });
}

function loadTextures(pack = true) {
  return new Promise((resolve, reject) => {
    axios.get(textureMap)
      .then((response) => new Promise((resolveImages, _rejectImages) => {
        const map = response.data;
        const imgs = Object.create(null);
        let texturesLeft = Object.keys(map).length;
        for (const key in map) {
          const url = map[key];
          const img = document.createElement('img');
          img.addEventListener('load', () => {
            console.info(`Loaded texture "${key}" from URL "${url}"`);
            imgs[key] = img;
            texturesLeft -= 1;
            if (!texturesLeft) {
              resolveImages(imgs);
            }
          }, { once: true });
          img.addEventListener('error', () => {
            console.error(`Failed to load texture "${key}" from URL "${url}"`);
          }, { once: true });
          img.src = url;
        }
      }))
      .then((imgs) => {
        if (pack) {
          const canvas = document.createElement('canvas');
          const atlas = new Atlas(canvas, {tilepad: true});
          for (const key in imgs) {
            const img = imgs[key];
            atlas.expand(key, img);
          }
          const base = new BaseTexture(canvas);
          const uvs = atlas.uv();
          const atlasWidth = canvas.width;
          const atlasHeight = canvas.height;
          for (const key in imgs) {
            const uv = uvs[key];
            const img = imgs[key];
            const uvTopLeft = uv[0];
            const [uvX, uvY] = uvTopLeft;
            const frame = new Rectangle(
              uvX * atlasWidth,
              uvY * atlasHeight,
              img.width,
              img.height);
            const texture = new Texture(base, frame);
            Texture.addTextureToCache(texture, key);
          }
        } else {
          for (const key in imgs) {
            const url = imgs[key].src;
            const texture = Texture.from(url);
            Texture.removeTextureFromCache(url);
            Texture.addTextureToCache(texture, key);
          }
        }
        resolve();
      })
      .catch((err) => reject(err));
  });
}
